c = arm-none-eabi-gcc 
#The arm-none-eabi-gcc is generic to all arm processers + its default
#instruction set is arm set(32 bits instructions)but our M4 works on Thumb set (16bit)
#We will call a flag that define M4 processer and Thumb set used
#We call this things before main.c and after the -c 

FLAG = -c -mcpu-cortex-m4 -mthumb

#you have to pass the linkerScript to the makefile as I did
#I am generating the map file(generated by the linker) which conaintains all the information about the 
# code in terms of memory sections

LSFLAG = -T linkerScript.ld -nostdlib -Wl,-Map=final.map

#This are some rules to be generated when i call make Rule
#Rule-->main.o or MGPIO_program.o,..
#Note that the dependency meaing that the rule will be generated if any change 
#occured in the dependency


main.o: main.c
	   $(c) $(FLAG) $^ -o $@ 
	
MGPIO_program.o: MGPIO_program.c 
   	   $(c) $(FLAG) $^ -o $@ 
	   
MRCC_program.o: MRCC_program.c 
   	   $(c) $(FLAG) $^ -o $@
	 
startup_file.o: startup_file.c
       $(c) $(FLAG) $^ -o $@
	 
final.elf: main.o MGPIO_program.o MRCC_program.o startup_file.o
       $(c) $(LSFLAG) $^ -o $@

#I will add some rules to ease my process
#This rule will generate all the .o files 
#This rule doesnt have a dependency, it just excute the previous rules
#To use it just call in the Git cmd --> make Build_All

Build_All: main.o MGPIO_program.o MRCC_program.o startup_file.o final.elf

#This rule uses a linux command to delete all the .o files (*.o) & elf files (*.elf)
#To use it --> make Clear

Clear: 
rm -f *.o *.elf







