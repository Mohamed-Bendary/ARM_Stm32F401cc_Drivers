/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "STD_TYPES.h"
#include "BIT_MATH.h"

#include "RCC_Interface.h"
#include "GPIO_interface.h"
#include "FMI_Interace.h"
#include "UART_interface.h"
#include "STK_int.h"
#include "Hex_Parser.h"

uint8_t msg[] = "ok";
uint8_t Data[50] = {0};
uint8_t  Local_u8UART_Status;
uint8_t counter = 0;
uint32_t i;
void App_code(void)
{
	/*Making a pointer to function which is the reset handler*/
	void (*App_code)(void);

	//uint32_t MSP_VALUE = *((volatile uint32_t*)(0x08004000));
	//__asm volatile("MSR MSP , %0"::"r"(MSP_VALUE));

	/*The reset handler is the second element of the vector table of the application
	 * code which address is 0x08004004*/

	/*The vector table second element is the reset handler, but i want to execute it
	 * so I dereferenced the address 0x08004004 which calls the reset handler function
	 * which calls the main function of the app code in the end after initializing
	 * .bss by zero and so on*/
	uint32_t ResetHandlerAddress = *((volatile uint32_t*)(0x08004004));
	App_code =  (void*)ResetHandlerAddress;

	/*Executing the reset handler*/
	App_code();
}

int main(void)
{

	/* Init system Clock*/
	MRCC_voidInit();

	/* Enable Peripherals RCC clock*/
	MRCC_voidEnablePerClk(AHB1,0); //GPIOA
	MRCC_voidEnableLOWPerClk(AHB1,15); //Flash driver
	MRCC_voidEnablePerClk(APB2,4); //USART1

	/* UART INIT*/
	MGPIO_voidSetPinDirection(GPIOA_PORT, PIN9, AF_PUSH_PULL, MEDIUM_SPEED);
	MGPIO_voidSetPinDirection(GPIOA_PORT, PIN10, AF_PUSH_PULL, MEDIUM_SPEED);

	/* SET PIN 9&10 PORTA as UART1 TX&RX */
	MGPIO_voidSetAF(GPIOA_PORT, PIN9, AF_UART);
	MGPIO_voidSetAF(GPIOA_PORT, PIN10, AF_UART);

	USART_InitType uart = {9600 , MODE_8BIT , STOP_BIT_1 , DISABLE , EVEN_PARITY , TX_RX,DISABLE , OVER_SAMPLING_16 };
	USART_ClockInitTypeDef UART_CLOCK = {DISABLE , 0,0,0};

	MUSART_voidInit(&uart, &UART_CLOCK, USART1);
	MUSART_Enable(USART1);

	/* STK INIT */
	MSTK_vInit();
	MSTK_vSetInterval_single(50000000, App_code);

	while(1)
	{
		/* check if there is data received by UART */
		Local_u8UART_Status = MUSART_u8ReceiveByteSynch(USART1 ,&Data[counter]);
		if(Local_u8UART_Status == 1)
		{
			/* Disable STK */
			MSTK_vStopTimer();

			/* Memory Erase */
			/* I wont erase the memory because the flashing tool has a bug
			 * that after each record it waits for the ACK "ok" with a timeout
			 * and erasing the memory takes time that the tool will collapse
			 * But normally the memory should be erased */

			//Erase the memory you will fill

			if(Data[counter] == '\n')
			{
				/* parsing Data */
				if(Data[8] == 4)
				{
					__asm("NOP");
				}
				else
				{
					HexParser_vParseData((uint8_t*)Data);
				}

				/* Send ACK to sender tool */
				MUSART_voidTransmitString(USART1, (uint8_t*)msg);

				/* Reset the counter to overwrite the array with the new record */
				counter = 0;
			}
			else
			{
				counter++;
			}

			/* Checking that the 8th index of the record is == '1' or not because
			 * the last record in the hex file has "01" as a record so '1' is the 8th element
			 * only in the end of record */
			if(Data[8] == '1')
			{
				MSTK_vSetInterval_single(10000000, App_code);
			}
		}
	}
}
